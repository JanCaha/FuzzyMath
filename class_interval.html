<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>FuzzyMath.class_interval API documentation</title>
<meta name="description" content="Class Interval" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>FuzzyMath.class_interval</code></h1>
</header>
<section id="section-intro">
<p>Class Interval</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Class Interval&#34;&#34;&#34;
from __future__ import annotations

import math
from decimal import Decimal, InvalidOperation
from inspect import BoundArguments, signature
from types import BuiltinFunctionType, FunctionType
from typing import Callable, Union

import numpy as np

from .class_precision import FuzzyMathPrecision


class Interval:
    &#34;&#34;&#34;
    Interval representation.

    ...

    Attributes
    ----------
    _min: Decimal
        Minimal value of interval.

    _max: Decimal
        Maximal value of interval.

    _degenerate: bool
        Is the interval degenerate? Degenerate interval have _min == _max.
    &#34;&#34;&#34;

    __slots__ = (&#34;_min&#34;, &#34;_max&#34;, &#34;_degenerate&#34;)

    def __init__(self, a: Union[str, int, float, Decimal], b: Union[str, int, float, Decimal]):
        &#34;&#34;&#34;
        Default constructor of interval. But generally it is more useful to use functions
        `IntervalFactory.infimum_supremum()`, `IntervalFactory.empty()`, `IntervalFactory.two_values()`
        and `IntervalFactory.midpoint_width()` instead of this function.

        Parameters
        ----------
        a: Union[str, int, float, Decimal]
        b: Union[str, int, float, Decimal]
        &#34;&#34;&#34;

        try:
            a = FuzzyMathPrecision.prepare_number(Decimal(a)).normalize()
        except InvalidOperation as e:
            raise InvalidOperation(f&#34;Cannot convert value `{a}` to number.&#34;) from e

        try:
            b = FuzzyMathPrecision.prepare_number(Decimal(b)).normalize()
        except InvalidOperation as e:
            raise InvalidOperation(f&#34;Cannot convert value `{b}` to number.&#34;) from e

        self._degenerate = False

        if a.is_nan() or b.is_nan():
            self._min = Decimal(&#34;nan&#34;)
            self._max = Decimal(&#34;nan&#34;)
        else:
            self._min = min(a, b)
            self._max = max(a, b)

        if self._min == self._max:
            self._degenerate = True

    def __repr__(self):
        &#34;&#34;&#34;
        Representation of Interval.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return f&#34;[{self.min}, {self.max}]&#34;

    @property
    def min(self) -&gt; Decimal:
        &#34;&#34;&#34;
        Minimal value of `Interval`.

        Returns
        -------
        Decimal
        &#34;&#34;&#34;
        return self._min

    @property
    def max(self) -&gt; Decimal:
        &#34;&#34;&#34;
        Maximal value of `Interval`.

        Returns
        -------
        Decimal
        &#34;&#34;&#34;
        return self._max

    @property
    def degenerate(self) -&gt; bool:
        &#34;&#34;&#34;
        Is this `Interval` degenerate? Degenerate Interval have minimum == maximum.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return self._degenerate

    @property
    def width(self) -&gt; Decimal:
        &#34;&#34;&#34;
        Width of interval. Width is equal to maximum - minimum.

        Returns
        -------
        Decimal
        &#34;&#34;&#34;
        return self._max - self._min

    @property
    def mid_point(self) -&gt; Decimal:
        &#34;&#34;&#34;
        Middle point of `Interval`. Middle point is calculated as (minimum + maximum) / 2.

        Returns
        -------
        Decimal
        &#34;&#34;&#34;
        if self.degenerate:
            return self._min
        else:
            return (self._min + self.max) / 2

    @property
    def is_empty(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the `Interval` is empty.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return math.isnan(self.min) and math.isnan(self.max)

    def __contains__(self, item) -&gt; bool:
        if isinstance(item, (int, float, Decimal)):
            return self.min &lt;= item &lt;= self.max
        elif isinstance(item, Interval):
            return self.min &lt;= item.min and item.max &lt;= self.max
        else:
            raise TypeError(
                f&#34;Cannot test if object of type `{type(item).__name__}` is in Interval. &#34;
                &#34;Only implemented for `float`, `int` and `Interval`.&#34;
            )

    def intersects(self, other: Interval) -&gt; bool:
        &#34;&#34;&#34;
        Does this `Interval` intersects to `other`.

        Parameters
        ----------
        other: Interval

        Returns
        -------
        bool
        &#34;&#34;&#34;
        if other.max &lt; self.min:
            return False

        if self.max &lt; other.min:
            return False

        return True

    def intersection(self, other: Interval) -&gt; Interval:
        &#34;&#34;&#34;
        Returns intersection of two `Interval`s.

        Parameters
        ----------
        other: Interval

        Returns
        -------
        Interval

        Raises
        -------
        ArithmeticError
            If this and other `Interval`s do not intersect.
        &#34;&#34;&#34;
        if self.intersects(other):
            return Interval(max(self.min, other.min), min(self.max, other.max))
        else:
            raise ArithmeticError(f&#34;Intervals `{self}` and `{other}` do not intersect, cannot construct intersection.&#34;)

    def union(self, other) -&gt; Interval:
        &#34;&#34;&#34;
        Returns union of two `Interval`s.

        Parameters
        ----------
        other: Interval

        Returns
        -------
        Interval

        Raises
        -------
        ArithmeticError
            If this and other `Interval`s do not intersect.
        &#34;&#34;&#34;
        if self.intersects(other):
            return Interval(min(self.min, other.min), max(self.max, other.max))
        else:
            raise ArithmeticError(f&#34;Intervals `{self}` and `{other}` do not intersect, cannot construct valid union.&#34;)

    def union_hull(self, other) -&gt; Interval:
        &#34;&#34;&#34;
        Returns union hull of two `Interval`s. Union hull is the widest interval covering both intervals.

        Parameters
        ----------
        other: Interval

        Returns
        -------
        Interval
        &#34;&#34;&#34;
        return Interval(min(self.min, other.min), max(self.max, other.max))

    def is_negative(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the `Interval` is strictly negative. Maximum &lt; 0.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return self.max &lt; 0

    def is_not_positive(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the `Interval` is not positive. Maximum &lt;= 0.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return self.max &lt;= 0

    def is_positive(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the `Interval` is strictly positive. Minimum &gt; 0.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return 0 &lt; self.min

    def is_not_negative(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the `Interval` is not negative. Minimum &gt;= 0.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return 0 &lt;= self.min

    def is_more_positive(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the midpoint of the interval is positive.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return 0 &lt;= self.mid_point

    def apply_function(
        self, function: Callable, *args, monotone: bool = False, number_elements: Union[float, Decimal] = 1000, **kwargs
    ) -&gt; Interval:
        &#34;&#34;&#34;
        Apply mathematical function to interval.

        Parameters
        ----------
        function: (FunctionType, BuiltinFunctionType)
            Function to apply to fuzzy number.

        args
            Positional arguments for the `function`.

        monotone: bool
            Is the function monotone? Default `False`. If `True` can significantly speed up calculation.

        number_elements: int
            Number of elements to divide fuzzy number into, if the function is not monotone. Default is `1000`.

        kwargs
            Named arguments to pass into `function`.

        Returns
        -------
        Interval
            New `Interval`.
        &#34;&#34;&#34;

        if not isinstance(function, (FunctionType, BuiltinFunctionType)):
            raise TypeError(f&#34;`function` needs to be a function. It is `{type(function).__name__}`.&#34;)

        if self.degenerate:
            elements = [self.min]
        elif monotone:
            elements = [self.min, self.max]
        else:
            step = (self.max - self.min) / Decimal(number_elements)

            elements = np.arange(self.min, self.max + (Decimal(0.1) * step), step=step).tolist()

        function_signature = signature(function)

        results = [0] * len(elements)

        for i, element in enumerate(elements):
            bound_params: BoundArguments = function_signature.bind(element, *args, **kwargs)
            bound_params.apply_defaults()

            results[i] = function(*bound_params.args, **bound_params.kwargs)

        return Interval(min(results), max(results))

    def __add__(self, other) -&gt; Interval:
        if isinstance(other, (float, int, Decimal)):
            return Interval(self.min + Decimal(other), self.max + Decimal(other))
        elif isinstance(other, Interval):
            return Interval(self.min + other.min, self.max + other.max)
        else:
            return NotImplemented

    def __radd__(self, other) -&gt; Interval:
        return self + other

    def __sub__(self, other) -&gt; Interval:
        if isinstance(other, (float, int, Decimal)):
            return Interval(self.min - Decimal(other), self.max - Decimal(other))
        elif isinstance(other, Interval):
            return Interval(self.min - other.max, self.max - other.min)
        else:
            return NotImplemented

    def __rsub__(self, other) -&gt; Interval:
        if isinstance(other, (float, int, Decimal)):
            return Interval(Decimal(other) - self.min, Decimal(other) - self.max)
        else:
            return NotImplemented

    def __mul__(self, other) -&gt; Interval:
        if isinstance(other, (float, int, Decimal)):
            values = [
                self.min * Decimal(other),
                self.min * Decimal(other),
                self.max * Decimal(other),
                self.max * Decimal(other),
            ]
            return Interval(min(values), max(values))
        elif isinstance(other, Interval):
            values = [self.min * other.min, self.min * other.max, self.max * other.min, self.max * other.max]
            return Interval(min(values), max(values))
        else:
            return NotImplemented

    def __rmul__(self, other) -&gt; Interval:
        return self * other

    def __truediv__(self, other) -&gt; Interval:
        if isinstance(other, (float, int, Decimal)):
            if other == 0:
                raise ArithmeticError(&#34;Cannot divide by 0.&#34;)

            values = [
                self.min / Decimal(other),
                self.min / Decimal(other),
                self.max / Decimal(other),
                self.max / Decimal(other),
            ]

            return Interval(min(values), max(values))

        elif isinstance(other, Interval):
            if 0 in other:
                raise ArithmeticError(f&#34;Cannot divide by interval that contains `0`. The interval is `{other}`.&#34;)

            values = [self.min / other.min, self.min / other.max, self.max / other.min, self.max / other.max]

            return Interval(min(values), max(values))

        else:
            return NotImplemented

    def __rtruediv__(self, other) -&gt; Interval:
        if isinstance(other, (float, int, Decimal)):
            values = [
                Decimal(other) / self.min,
                Decimal(other) / self.min,
                Decimal(other) / self.max,
                Decimal(other) / self.max,
            ]

            return Interval(min(values), max(values))

        else:
            return NotImplemented

    def __pow__(self, power) -&gt; Interval:
        if isinstance(power, int):
            min_power = self.min ** Decimal(power)
            max_power = self.max ** Decimal(power)

            if (power % 2) == 0:
                if self.min &lt;= 0 &lt;= self.max:
                    min_res = min(Decimal(0), max(min_power, max_power))
                    max_res = max(Decimal(0), min_power, max_power)

                else:
                    min_res = min(min_power, max_power)
                    max_res = max(min_power, max_power)

            else:
                min_res = min(min_power, max_power)
                max_res = max(min_power, max_power)

            return Interval(min_res, max_res)

        else:
            return NotImplemented

    # def __abs__(self):
    #     return Interval.two_values(math.fabs(self.min),
    #                                math.fabs(self.max), precision=self.precision)

    def __neg__(self) -&gt; Interval:
        return Interval(self.min * (-1), self.max * (-1))

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, Interval):
            return self.min == other.min and self.max == other.max

        else:
            return NotImplemented

    def __lt__(self, other) -&gt; bool:
        return self.max &lt; other.min

    def __gt__(self, other) -&gt; bool:
        return self.min &gt; other.max

    def __hash__(self) -&gt; int:
        return hash((self.min, self.max))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="FuzzyMath.class_interval.Interval"><code class="flex name class">
<span>class <span class="ident">Interval</span></span>
<span>(</span><span>a: Union[str, int, float, Decimal], b: Union[str, int, float, Decimal])</span>
</code></dt>
<dd>
<div class="desc"><p>Interval representation.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>_min</code></strong> :&ensp;<code>Decimal</code></dt>
<dd>Minimal value of interval.</dd>
<dt><strong><code>_max</code></strong> :&ensp;<code>Decimal</code></dt>
<dd>Maximal value of interval.</dd>
<dt><strong><code>_degenerate</code></strong> :&ensp;<code>bool</code></dt>
<dd>Is the interval degenerate? Degenerate interval have _min == _max.</dd>
</dl>
<p>Default constructor of interval. But generally it is more useful to use functions
<code>IntervalFactory.infimum_supremum()</code>, <code>IntervalFactory.empty()</code>, <code>IntervalFactory.two_values()</code>
and <code>IntervalFactory.midpoint_width()</code> instead of this function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>Union[str, int, float, Decimal]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>Union[str, int, float, Decimal]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Interval:
    &#34;&#34;&#34;
    Interval representation.

    ...

    Attributes
    ----------
    _min: Decimal
        Minimal value of interval.

    _max: Decimal
        Maximal value of interval.

    _degenerate: bool
        Is the interval degenerate? Degenerate interval have _min == _max.
    &#34;&#34;&#34;

    __slots__ = (&#34;_min&#34;, &#34;_max&#34;, &#34;_degenerate&#34;)

    def __init__(self, a: Union[str, int, float, Decimal], b: Union[str, int, float, Decimal]):
        &#34;&#34;&#34;
        Default constructor of interval. But generally it is more useful to use functions
        `IntervalFactory.infimum_supremum()`, `IntervalFactory.empty()`, `IntervalFactory.two_values()`
        and `IntervalFactory.midpoint_width()` instead of this function.

        Parameters
        ----------
        a: Union[str, int, float, Decimal]
        b: Union[str, int, float, Decimal]
        &#34;&#34;&#34;

        try:
            a = FuzzyMathPrecision.prepare_number(Decimal(a)).normalize()
        except InvalidOperation as e:
            raise InvalidOperation(f&#34;Cannot convert value `{a}` to number.&#34;) from e

        try:
            b = FuzzyMathPrecision.prepare_number(Decimal(b)).normalize()
        except InvalidOperation as e:
            raise InvalidOperation(f&#34;Cannot convert value `{b}` to number.&#34;) from e

        self._degenerate = False

        if a.is_nan() or b.is_nan():
            self._min = Decimal(&#34;nan&#34;)
            self._max = Decimal(&#34;nan&#34;)
        else:
            self._min = min(a, b)
            self._max = max(a, b)

        if self._min == self._max:
            self._degenerate = True

    def __repr__(self):
        &#34;&#34;&#34;
        Representation of Interval.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return f&#34;[{self.min}, {self.max}]&#34;

    @property
    def min(self) -&gt; Decimal:
        &#34;&#34;&#34;
        Minimal value of `Interval`.

        Returns
        -------
        Decimal
        &#34;&#34;&#34;
        return self._min

    @property
    def max(self) -&gt; Decimal:
        &#34;&#34;&#34;
        Maximal value of `Interval`.

        Returns
        -------
        Decimal
        &#34;&#34;&#34;
        return self._max

    @property
    def degenerate(self) -&gt; bool:
        &#34;&#34;&#34;
        Is this `Interval` degenerate? Degenerate Interval have minimum == maximum.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return self._degenerate

    @property
    def width(self) -&gt; Decimal:
        &#34;&#34;&#34;
        Width of interval. Width is equal to maximum - minimum.

        Returns
        -------
        Decimal
        &#34;&#34;&#34;
        return self._max - self._min

    @property
    def mid_point(self) -&gt; Decimal:
        &#34;&#34;&#34;
        Middle point of `Interval`. Middle point is calculated as (minimum + maximum) / 2.

        Returns
        -------
        Decimal
        &#34;&#34;&#34;
        if self.degenerate:
            return self._min
        else:
            return (self._min + self.max) / 2

    @property
    def is_empty(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the `Interval` is empty.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return math.isnan(self.min) and math.isnan(self.max)

    def __contains__(self, item) -&gt; bool:
        if isinstance(item, (int, float, Decimal)):
            return self.min &lt;= item &lt;= self.max
        elif isinstance(item, Interval):
            return self.min &lt;= item.min and item.max &lt;= self.max
        else:
            raise TypeError(
                f&#34;Cannot test if object of type `{type(item).__name__}` is in Interval. &#34;
                &#34;Only implemented for `float`, `int` and `Interval`.&#34;
            )

    def intersects(self, other: Interval) -&gt; bool:
        &#34;&#34;&#34;
        Does this `Interval` intersects to `other`.

        Parameters
        ----------
        other: Interval

        Returns
        -------
        bool
        &#34;&#34;&#34;
        if other.max &lt; self.min:
            return False

        if self.max &lt; other.min:
            return False

        return True

    def intersection(self, other: Interval) -&gt; Interval:
        &#34;&#34;&#34;
        Returns intersection of two `Interval`s.

        Parameters
        ----------
        other: Interval

        Returns
        -------
        Interval

        Raises
        -------
        ArithmeticError
            If this and other `Interval`s do not intersect.
        &#34;&#34;&#34;
        if self.intersects(other):
            return Interval(max(self.min, other.min), min(self.max, other.max))
        else:
            raise ArithmeticError(f&#34;Intervals `{self}` and `{other}` do not intersect, cannot construct intersection.&#34;)

    def union(self, other) -&gt; Interval:
        &#34;&#34;&#34;
        Returns union of two `Interval`s.

        Parameters
        ----------
        other: Interval

        Returns
        -------
        Interval

        Raises
        -------
        ArithmeticError
            If this and other `Interval`s do not intersect.
        &#34;&#34;&#34;
        if self.intersects(other):
            return Interval(min(self.min, other.min), max(self.max, other.max))
        else:
            raise ArithmeticError(f&#34;Intervals `{self}` and `{other}` do not intersect, cannot construct valid union.&#34;)

    def union_hull(self, other) -&gt; Interval:
        &#34;&#34;&#34;
        Returns union hull of two `Interval`s. Union hull is the widest interval covering both intervals.

        Parameters
        ----------
        other: Interval

        Returns
        -------
        Interval
        &#34;&#34;&#34;
        return Interval(min(self.min, other.min), max(self.max, other.max))

    def is_negative(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the `Interval` is strictly negative. Maximum &lt; 0.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return self.max &lt; 0

    def is_not_positive(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the `Interval` is not positive. Maximum &lt;= 0.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return self.max &lt;= 0

    def is_positive(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the `Interval` is strictly positive. Minimum &gt; 0.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return 0 &lt; self.min

    def is_not_negative(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the `Interval` is not negative. Minimum &gt;= 0.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return 0 &lt;= self.min

    def is_more_positive(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the midpoint of the interval is positive.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return 0 &lt;= self.mid_point

    def apply_function(
        self, function: Callable, *args, monotone: bool = False, number_elements: Union[float, Decimal] = 1000, **kwargs
    ) -&gt; Interval:
        &#34;&#34;&#34;
        Apply mathematical function to interval.

        Parameters
        ----------
        function: (FunctionType, BuiltinFunctionType)
            Function to apply to fuzzy number.

        args
            Positional arguments for the `function`.

        monotone: bool
            Is the function monotone? Default `False`. If `True` can significantly speed up calculation.

        number_elements: int
            Number of elements to divide fuzzy number into, if the function is not monotone. Default is `1000`.

        kwargs
            Named arguments to pass into `function`.

        Returns
        -------
        Interval
            New `Interval`.
        &#34;&#34;&#34;

        if not isinstance(function, (FunctionType, BuiltinFunctionType)):
            raise TypeError(f&#34;`function` needs to be a function. It is `{type(function).__name__}`.&#34;)

        if self.degenerate:
            elements = [self.min]
        elif monotone:
            elements = [self.min, self.max]
        else:
            step = (self.max - self.min) / Decimal(number_elements)

            elements = np.arange(self.min, self.max + (Decimal(0.1) * step), step=step).tolist()

        function_signature = signature(function)

        results = [0] * len(elements)

        for i, element in enumerate(elements):
            bound_params: BoundArguments = function_signature.bind(element, *args, **kwargs)
            bound_params.apply_defaults()

            results[i] = function(*bound_params.args, **bound_params.kwargs)

        return Interval(min(results), max(results))

    def __add__(self, other) -&gt; Interval:
        if isinstance(other, (float, int, Decimal)):
            return Interval(self.min + Decimal(other), self.max + Decimal(other))
        elif isinstance(other, Interval):
            return Interval(self.min + other.min, self.max + other.max)
        else:
            return NotImplemented

    def __radd__(self, other) -&gt; Interval:
        return self + other

    def __sub__(self, other) -&gt; Interval:
        if isinstance(other, (float, int, Decimal)):
            return Interval(self.min - Decimal(other), self.max - Decimal(other))
        elif isinstance(other, Interval):
            return Interval(self.min - other.max, self.max - other.min)
        else:
            return NotImplemented

    def __rsub__(self, other) -&gt; Interval:
        if isinstance(other, (float, int, Decimal)):
            return Interval(Decimal(other) - self.min, Decimal(other) - self.max)
        else:
            return NotImplemented

    def __mul__(self, other) -&gt; Interval:
        if isinstance(other, (float, int, Decimal)):
            values = [
                self.min * Decimal(other),
                self.min * Decimal(other),
                self.max * Decimal(other),
                self.max * Decimal(other),
            ]
            return Interval(min(values), max(values))
        elif isinstance(other, Interval):
            values = [self.min * other.min, self.min * other.max, self.max * other.min, self.max * other.max]
            return Interval(min(values), max(values))
        else:
            return NotImplemented

    def __rmul__(self, other) -&gt; Interval:
        return self * other

    def __truediv__(self, other) -&gt; Interval:
        if isinstance(other, (float, int, Decimal)):
            if other == 0:
                raise ArithmeticError(&#34;Cannot divide by 0.&#34;)

            values = [
                self.min / Decimal(other),
                self.min / Decimal(other),
                self.max / Decimal(other),
                self.max / Decimal(other),
            ]

            return Interval(min(values), max(values))

        elif isinstance(other, Interval):
            if 0 in other:
                raise ArithmeticError(f&#34;Cannot divide by interval that contains `0`. The interval is `{other}`.&#34;)

            values = [self.min / other.min, self.min / other.max, self.max / other.min, self.max / other.max]

            return Interval(min(values), max(values))

        else:
            return NotImplemented

    def __rtruediv__(self, other) -&gt; Interval:
        if isinstance(other, (float, int, Decimal)):
            values = [
                Decimal(other) / self.min,
                Decimal(other) / self.min,
                Decimal(other) / self.max,
                Decimal(other) / self.max,
            ]

            return Interval(min(values), max(values))

        else:
            return NotImplemented

    def __pow__(self, power) -&gt; Interval:
        if isinstance(power, int):
            min_power = self.min ** Decimal(power)
            max_power = self.max ** Decimal(power)

            if (power % 2) == 0:
                if self.min &lt;= 0 &lt;= self.max:
                    min_res = min(Decimal(0), max(min_power, max_power))
                    max_res = max(Decimal(0), min_power, max_power)

                else:
                    min_res = min(min_power, max_power)
                    max_res = max(min_power, max_power)

            else:
                min_res = min(min_power, max_power)
                max_res = max(min_power, max_power)

            return Interval(min_res, max_res)

        else:
            return NotImplemented

    # def __abs__(self):
    #     return Interval.two_values(math.fabs(self.min),
    #                                math.fabs(self.max), precision=self.precision)

    def __neg__(self) -&gt; Interval:
        return Interval(self.min * (-1), self.max * (-1))

    def __eq__(self, other) -&gt; bool:
        if isinstance(other, Interval):
            return self.min == other.min and self.max == other.max

        else:
            return NotImplemented

    def __lt__(self, other) -&gt; bool:
        return self.max &lt; other.min

    def __gt__(self, other) -&gt; bool:
        return self.min &gt; other.max

    def __hash__(self) -&gt; int:
        return hash((self.min, self.max))</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="FuzzyMath.class_interval.Interval.degenerate"><code class="name">var <span class="ident">degenerate</span> : bool</code></dt>
<dd>
<div class="desc"><p>Is this <code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code> degenerate? Degenerate Interval have minimum == maximum.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def degenerate(self) -&gt; bool:
    &#34;&#34;&#34;
    Is this `Interval` degenerate? Degenerate Interval have minimum == maximum.

    Returns
    -------
    bool
    &#34;&#34;&#34;
    return self._degenerate</code></pre>
</details>
</dd>
<dt id="FuzzyMath.class_interval.Interval.is_empty"><code class="name">var <span class="ident">is_empty</span> : bool</code></dt>
<dd>
<div class="desc"><p>Checks if the <code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code> is empty.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_empty(self) -&gt; bool:
    &#34;&#34;&#34;
    Checks if the `Interval` is empty.

    Returns
    -------
    bool
    &#34;&#34;&#34;
    return math.isnan(self.min) and math.isnan(self.max)</code></pre>
</details>
</dd>
<dt id="FuzzyMath.class_interval.Interval.max"><code class="name">var <span class="ident">max</span> : decimal.Decimal</code></dt>
<dd>
<div class="desc"><p>Maximal value of <code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Decimal</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max(self) -&gt; Decimal:
    &#34;&#34;&#34;
    Maximal value of `Interval`.

    Returns
    -------
    Decimal
    &#34;&#34;&#34;
    return self._max</code></pre>
</details>
</dd>
<dt id="FuzzyMath.class_interval.Interval.mid_point"><code class="name">var <span class="ident">mid_point</span> : decimal.Decimal</code></dt>
<dd>
<div class="desc"><p>Middle point of <code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code>. Middle point is calculated as (minimum + maximum) / 2.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Decimal</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mid_point(self) -&gt; Decimal:
    &#34;&#34;&#34;
    Middle point of `Interval`. Middle point is calculated as (minimum + maximum) / 2.

    Returns
    -------
    Decimal
    &#34;&#34;&#34;
    if self.degenerate:
        return self._min
    else:
        return (self._min + self.max) / 2</code></pre>
</details>
</dd>
<dt id="FuzzyMath.class_interval.Interval.min"><code class="name">var <span class="ident">min</span> : decimal.Decimal</code></dt>
<dd>
<div class="desc"><p>Minimal value of <code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Decimal</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def min(self) -&gt; Decimal:
    &#34;&#34;&#34;
    Minimal value of `Interval`.

    Returns
    -------
    Decimal
    &#34;&#34;&#34;
    return self._min</code></pre>
</details>
</dd>
<dt id="FuzzyMath.class_interval.Interval.width"><code class="name">var <span class="ident">width</span> : decimal.Decimal</code></dt>
<dd>
<div class="desc"><p>Width of interval. Width is equal to maximum - minimum.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Decimal</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def width(self) -&gt; Decimal:
    &#34;&#34;&#34;
    Width of interval. Width is equal to maximum - minimum.

    Returns
    -------
    Decimal
    &#34;&#34;&#34;
    return self._max - self._min</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="FuzzyMath.class_interval.Interval.apply_function"><code class="name flex">
<span>def <span class="ident">apply_function</span></span>(<span>self, function: Callable, *args, monotone: bool = False, number_elements: Union[float, Decimal] = 1000, **kwargs) ‑> <a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></span>
</code></dt>
<dd>
<div class="desc"><p>Apply mathematical function to interval.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>function</code></strong> :&ensp;<code>(FunctionType, BuiltinFunctionType)</code></dt>
<dd>Function to apply to fuzzy number.</dd>
<dt><strong><code>args</code></strong></dt>
<dd>Positional arguments for the <code>function</code>.</dd>
<dt><strong><code>monotone</code></strong> :&ensp;<code>bool</code></dt>
<dd>Is the function monotone? Default <code>False</code>. If <code>True</code> can significantly speed up calculation.</dd>
<dt><strong><code>number_elements</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of elements to divide fuzzy number into, if the function is not monotone. Default is <code>1000</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Named arguments to pass into <code>function</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code></dt>
<dd>New <code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_function(
    self, function: Callable, *args, monotone: bool = False, number_elements: Union[float, Decimal] = 1000, **kwargs
) -&gt; Interval:
    &#34;&#34;&#34;
    Apply mathematical function to interval.

    Parameters
    ----------
    function: (FunctionType, BuiltinFunctionType)
        Function to apply to fuzzy number.

    args
        Positional arguments for the `function`.

    monotone: bool
        Is the function monotone? Default `False`. If `True` can significantly speed up calculation.

    number_elements: int
        Number of elements to divide fuzzy number into, if the function is not monotone. Default is `1000`.

    kwargs
        Named arguments to pass into `function`.

    Returns
    -------
    Interval
        New `Interval`.
    &#34;&#34;&#34;

    if not isinstance(function, (FunctionType, BuiltinFunctionType)):
        raise TypeError(f&#34;`function` needs to be a function. It is `{type(function).__name__}`.&#34;)

    if self.degenerate:
        elements = [self.min]
    elif monotone:
        elements = [self.min, self.max]
    else:
        step = (self.max - self.min) / Decimal(number_elements)

        elements = np.arange(self.min, self.max + (Decimal(0.1) * step), step=step).tolist()

    function_signature = signature(function)

    results = [0] * len(elements)

    for i, element in enumerate(elements):
        bound_params: BoundArguments = function_signature.bind(element, *args, **kwargs)
        bound_params.apply_defaults()

        results[i] = function(*bound_params.args, **bound_params.kwargs)

    return Interval(min(results), max(results))</code></pre>
</details>
</dd>
<dt id="FuzzyMath.class_interval.Interval.intersection"><code class="name flex">
<span>def <span class="ident">intersection</span></span>(<span>self, other: <a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a>) ‑> <a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns intersection of two <code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code>s.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ArithmeticError</code></dt>
<dd>If this and other <code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code>s do not intersect.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersection(self, other: Interval) -&gt; Interval:
    &#34;&#34;&#34;
    Returns intersection of two `Interval`s.

    Parameters
    ----------
    other: Interval

    Returns
    -------
    Interval

    Raises
    -------
    ArithmeticError
        If this and other `Interval`s do not intersect.
    &#34;&#34;&#34;
    if self.intersects(other):
        return Interval(max(self.min, other.min), min(self.max, other.max))
    else:
        raise ArithmeticError(f&#34;Intervals `{self}` and `{other}` do not intersect, cannot construct intersection.&#34;)</code></pre>
</details>
</dd>
<dt id="FuzzyMath.class_interval.Interval.intersects"><code class="name flex">
<span>def <span class="ident">intersects</span></span>(<span>self, other: <a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Does this <code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code> intersects to <code>other</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersects(self, other: Interval) -&gt; bool:
    &#34;&#34;&#34;
    Does this `Interval` intersects to `other`.

    Parameters
    ----------
    other: Interval

    Returns
    -------
    bool
    &#34;&#34;&#34;
    if other.max &lt; self.min:
        return False

    if self.max &lt; other.min:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="FuzzyMath.class_interval.Interval.is_more_positive"><code class="name flex">
<span>def <span class="ident">is_more_positive</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the midpoint of the interval is positive.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_more_positive(self) -&gt; bool:
    &#34;&#34;&#34;
    Checks if the midpoint of the interval is positive.

    Returns
    -------
    bool
    &#34;&#34;&#34;
    return 0 &lt;= self.mid_point</code></pre>
</details>
</dd>
<dt id="FuzzyMath.class_interval.Interval.is_negative"><code class="name flex">
<span>def <span class="ident">is_negative</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the <code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code> is strictly negative. Maximum &lt; 0.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_negative(self) -&gt; bool:
    &#34;&#34;&#34;
    Checks if the `Interval` is strictly negative. Maximum &lt; 0.

    Returns
    -------
    bool
    &#34;&#34;&#34;
    return self.max &lt; 0</code></pre>
</details>
</dd>
<dt id="FuzzyMath.class_interval.Interval.is_not_negative"><code class="name flex">
<span>def <span class="ident">is_not_negative</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the <code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code> is not negative. Minimum &gt;= 0.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_not_negative(self) -&gt; bool:
    &#34;&#34;&#34;
    Checks if the `Interval` is not negative. Minimum &gt;= 0.

    Returns
    -------
    bool
    &#34;&#34;&#34;
    return 0 &lt;= self.min</code></pre>
</details>
</dd>
<dt id="FuzzyMath.class_interval.Interval.is_not_positive"><code class="name flex">
<span>def <span class="ident">is_not_positive</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the <code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code> is not positive. Maximum &lt;= 0.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_not_positive(self) -&gt; bool:
    &#34;&#34;&#34;
    Checks if the `Interval` is not positive. Maximum &lt;= 0.

    Returns
    -------
    bool
    &#34;&#34;&#34;
    return self.max &lt;= 0</code></pre>
</details>
</dd>
<dt id="FuzzyMath.class_interval.Interval.is_positive"><code class="name flex">
<span>def <span class="ident">is_positive</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the <code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code> is strictly positive. Minimum &gt; 0.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_positive(self) -&gt; bool:
    &#34;&#34;&#34;
    Checks if the `Interval` is strictly positive. Minimum &gt; 0.

    Returns
    -------
    bool
    &#34;&#34;&#34;
    return 0 &lt; self.min</code></pre>
</details>
</dd>
<dt id="FuzzyMath.class_interval.Interval.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>self, other) ‑> <a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns union of two <code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code>s.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ArithmeticError</code></dt>
<dd>If this and other <code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code>s do not intersect.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union(self, other) -&gt; Interval:
    &#34;&#34;&#34;
    Returns union of two `Interval`s.

    Parameters
    ----------
    other: Interval

    Returns
    -------
    Interval

    Raises
    -------
    ArithmeticError
        If this and other `Interval`s do not intersect.
    &#34;&#34;&#34;
    if self.intersects(other):
        return Interval(min(self.min, other.min), max(self.max, other.max))
    else:
        raise ArithmeticError(f&#34;Intervals `{self}` and `{other}` do not intersect, cannot construct valid union.&#34;)</code></pre>
</details>
</dd>
<dt id="FuzzyMath.class_interval.Interval.union_hull"><code class="name flex">
<span>def <span class="ident">union_hull</span></span>(<span>self, other) ‑> <a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns union hull of two <code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code>s. Union hull is the widest interval covering both intervals.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union_hull(self, other) -&gt; Interval:
    &#34;&#34;&#34;
    Returns union hull of two `Interval`s. Union hull is the widest interval covering both intervals.

    Parameters
    ----------
    other: Interval

    Returns
    -------
    Interval
    &#34;&#34;&#34;
    return Interval(min(self.min, other.min), max(self.max, other.max))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="FuzzyMath" href="index.html">FuzzyMath</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="FuzzyMath.class_interval.Interval" href="#FuzzyMath.class_interval.Interval">Interval</a></code></h4>
<ul class="two-column">
<li><code><a title="FuzzyMath.class_interval.Interval.apply_function" href="#FuzzyMath.class_interval.Interval.apply_function">apply_function</a></code></li>
<li><code><a title="FuzzyMath.class_interval.Interval.degenerate" href="#FuzzyMath.class_interval.Interval.degenerate">degenerate</a></code></li>
<li><code><a title="FuzzyMath.class_interval.Interval.intersection" href="#FuzzyMath.class_interval.Interval.intersection">intersection</a></code></li>
<li><code><a title="FuzzyMath.class_interval.Interval.intersects" href="#FuzzyMath.class_interval.Interval.intersects">intersects</a></code></li>
<li><code><a title="FuzzyMath.class_interval.Interval.is_empty" href="#FuzzyMath.class_interval.Interval.is_empty">is_empty</a></code></li>
<li><code><a title="FuzzyMath.class_interval.Interval.is_more_positive" href="#FuzzyMath.class_interval.Interval.is_more_positive">is_more_positive</a></code></li>
<li><code><a title="FuzzyMath.class_interval.Interval.is_negative" href="#FuzzyMath.class_interval.Interval.is_negative">is_negative</a></code></li>
<li><code><a title="FuzzyMath.class_interval.Interval.is_not_negative" href="#FuzzyMath.class_interval.Interval.is_not_negative">is_not_negative</a></code></li>
<li><code><a title="FuzzyMath.class_interval.Interval.is_not_positive" href="#FuzzyMath.class_interval.Interval.is_not_positive">is_not_positive</a></code></li>
<li><code><a title="FuzzyMath.class_interval.Interval.is_positive" href="#FuzzyMath.class_interval.Interval.is_positive">is_positive</a></code></li>
<li><code><a title="FuzzyMath.class_interval.Interval.max" href="#FuzzyMath.class_interval.Interval.max">max</a></code></li>
<li><code><a title="FuzzyMath.class_interval.Interval.mid_point" href="#FuzzyMath.class_interval.Interval.mid_point">mid_point</a></code></li>
<li><code><a title="FuzzyMath.class_interval.Interval.min" href="#FuzzyMath.class_interval.Interval.min">min</a></code></li>
<li><code><a title="FuzzyMath.class_interval.Interval.union" href="#FuzzyMath.class_interval.Interval.union">union</a></code></li>
<li><code><a title="FuzzyMath.class_interval.Interval.union_hull" href="#FuzzyMath.class_interval.Interval.union_hull">union_hull</a></code></li>
<li><code><a title="FuzzyMath.class_interval.Interval.width" href="#FuzzyMath.class_interval.Interval.width">width</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>